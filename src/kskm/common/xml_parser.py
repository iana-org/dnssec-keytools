"""
Really minimalistic XML parser for parsing KSR XML documents.

Focus for this implementation is:

  1) not adding a dependency
  2) auditable code

NOT XML compliance. We just need to parse KSRs good enough.
"""

import logging
import re
from dataclasses import dataclass
from typing import Dict, Optional, Tuple, Union

__author__ = "ft"

_DEBUG_XML_PARSER = False


@dataclass(frozen=False)
class _XMLElement:
    name: str
    attrs: dict[str, str] | None
    value: str | dict


logger = logging.getLogger(__name__)


def parse_ksr(xml: str) -> dict:
    """
    Parse a KSR XML.

    Anything before the first '<KSR' is ignored.
    """
    idx = xml.index("<KSR")
    return parse(xml[idx:])


def parse(xml: str, recurse: int = 5) -> dict:
    """
    Parse something that is probably a KSR XML file without anything fancy in it into a dict.

    The XML provided to this function is expected to start with the "<KSR ...>" tag, and
    NOT the document header, e.g.:

            <?xml version="1.0" encoding="UTF-8"?>
            <!-- document generated by ksr-client.pl revision 75 -->

    The result is a nested tree of dicts, or lists of dicts if more than one element
    with a given name is found. See the unit tests for some real examples of input and output.

    :param xml: XML document
    :param recurse: Maximum level of recursion that will be done before aborting
    :return: Dictionary with parsed data
    """
    res: dict = {}
    _parse_recursively(xml, recurse=recurse, res=res)
    return res


def _parse_recursively(xml: str, recurse: int, res: dict) -> None:
    """
    Parse an XML element and all it's sub-elements.

    Parse the first element in an XML sub-string, and recursively call itself
    if the value contains further XML elements.

    :param xml: XML sub-string, possibly containing more XML sub-strings
    :param recurse: Levels of recursion permitted
    :param res: Resulting data dictionary, modified in-place
    """
    while xml:
        xml = xml.strip()
        if xml[0] != "<":
            raise ValueError(f"XML parser got lost at: {xml!r}")
        # start of element
        if _DEBUG_XML_PARSER:
            logger.debug(f"Start of element found: {xml[:20]!r}...")
        element, end_idx = parse_first_element(xml)
        sub_res: dict = {}
        # the isinstance helps the type checker be sure that element.value is in fact a string
        if isinstance(element.value, str) and element.value and element.value[0] == "<":
            # value is one or more new elements, recurse
            if not recurse:
                raise ValueError("XML maximum recursion depth exhausted")
            _parse_recursively(element.value, recurse - 1, sub_res)
            element.value = sub_res

        _store_element(element, res)

        # shave off the part of the XML we are now finished with
        xml = xml[end_idx:]


def _store_element(element: _XMLElement, res: dict) -> None:
    """
    Store an XML element in parsed form.

    Example: <KSR id='foo', domain='.'>test</KSR> has

      name = 'KSR'
      attrs = {'id': 'foo', 'domain': '.'}
      value = 'test'

    If `attrs` is not None, re-format the value into a small dict with
    the keys 'attrs' and 'value'.

    If an element with this `name` is already present in the `res` dictionary,
    turn res[name] into a list and append the new element to it.

    :param element: XML element
    :param res: Resulting data dictionary, modified in-place
    """
    value = element.value
    if element.attrs is not None:
        value = {
            "attrs": element.attrs,
            "value": value,
        }
    if element.name in res:
        # Element has been seen already, transform it to a list if it is not
        # and append the new element to the list
        if not isinstance(res[element.name], list):
            res[element.name] = [res[element.name]]
        res[element.name] += [value]
    else:
        # Element not previously found, add as a single value
        res[element.name] = value


def parse_first_element(xml: str) -> tuple[_XMLElement, int]:
    """
    Parse the first element from the start of the XML sub-string.

    :param xml: XML sub-string
    :return: Parsed element (name, attrs and value) and an index to the end of it in the XML sub-string
    """
    name, attrs, tag_end = _parse_tag(xml)
    if _DEBUG_XML_PARSER:
        logger.debug(f"Found tag {name} with attrs {attrs}")
    if xml[tag_end - 2 : tag_end] == "/>":
        # an element with no value
        return _XMLElement(name=name, attrs=attrs, value=""), tag_end
    value_start = tag_end
    value_end, element_end_idx = _find_end_of_element(xml, value_start, name)
    if _DEBUG_XML_PARSER:
        logger.debug(f"Found end of element {name} at idx {element_end_idx}")
    value = xml[value_start:value_end].strip()
    return _XMLElement(name=name, attrs=attrs, value=value), element_end_idx


def _parse_tag(xml: str) -> tuple[str, dict | None, int]:
    """
    Parse the first XML start-of-elements into name and attributes.

    Only three limited forms are supported:

    Example 1: <KSR id='foo', domain='.'>

      name = 'KSR'
      attrs = {'id': 'foo', 'domain': '.'}

    Example 2: <Request>

      name = 'Request'
      attrs = None

    Example 3: <Signer keyIdentifier="KC00020" />

      name = 'Signer'
      attrs = {'keyIdentifier': 'KC00020'}

    :param xml: XML sub-string
    :return: Element name, parsed attributes and index to whatever is after the tag
    """
    # regexp matching the case <KSR id='foo', domain='.'>
    m = re.match(r"<(\w+?)(\s+?)(.+?)(/*)>", xml)
    if m:
        name, ws, attrs, slash = m.groups()
        end_idx = len(name) + len(ws) + len(attrs) + len(slash) + 2
        return name, _parse_attrs(attrs), end_idx
    # Regexp matching the case <Request>
    m = re.match(r"<(\w+)>", xml)
    if m:
        name = m.groups()[0]
        end_idx = len(name) + 2
        return name, None, end_idx
    raise ValueError(f"Failed parsing tag {xml[:10]!r}...")


def _parse_attrs(attrs: str) -> dict:
    """
    Parse element attributes into a dict.

    Example: The string

      'id="foo" domain="."' is parsed into the dict
      {'id': 'foo', 'domain': '.'}

    :param attrs: Element sub-string
    :return: Element attributes as dictionary
    """
    res = {}
    while attrs:
        attrs = attrs.strip()
        m = re.match(r'^(\w+)="(.+?)"\s*(.*)', attrs)
        if m:
            name, value, attrs = m.groups()
            res[name] = value
    return res


def _find_end_of_element(xml: str, start_idx: int, name: str) -> tuple[int, int]:
    """
    Locate the end of an element whose name has already been determined.

    Support _one_ level of tag nesting, to handle the Signature element of KSRs that
    contain another Signature element.

    :param xml: XML sub-string
    :param start_idx: Index to start of element value
    :param name: Element name
    :return: End of value index, and end of element index
    """
    element_end_tag = f"</{name}>"
    end_idx = xml.index(element_end_tag, start_idx)
    # Now check if there is another starting tag for this name before the end tag we found
    for nested_tag in [f"<{name}>", f"<{name} "]:
        try:
            inner_idx = xml.index(nested_tag)
            if inner_idx and inner_idx < end_idx:
                end_idx = xml.index(element_end_tag, end_idx + len(element_end_tag))
        except ValueError:
            pass
    return end_idx, end_idx + len(element_end_tag)
